"""HTMLReportGenerator: self-contained HTML report with embedded Plotly.js charts."""

from __future__ import annotations

import html
import json
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from teco.reporting.tracker import ProgressTracker


class HTMLReportGenerator:
    """Generate a self-contained HTML report from a ProgressTracker snapshot."""

    def generate(self, tracker: ProgressTracker, output_dir: Path) -> Path:
        """Render the report and write it to ``output_dir/<run_id>_report.html``."""
        output_dir.mkdir(parents=True, exist_ok=True)
        path = output_dir / f"{tracker.run_id}_report.html"
        data = tracker.to_dict()
        html_content = self._render(data)
        path.write_text(html_content, encoding="utf-8")
        return path

    # ------------------------------------------------------------------
    # Template rendering
    # ------------------------------------------------------------------

    def _render(self, data: dict[str, Any]) -> str:
        run_id = data.get("run_id", "unknown")
        device = data.get("device_name", "unknown")
        peak_tflops = data.get("peak_tflops_fp16", 0)
        peak_bw = data.get("peak_bandwidth_gbs", 0)
        wall_time = data.get("wall_time_s", 0)
        final = data.get("final") or {}
        overall_speedup = final.get("overall_speedup", 1.0)
        total_iters = final.get("total_iterations", 0)
        max_iters = data.get("max_iterations", 0)

        baseline = data.get("baseline", [])
        strategies = data.get("strategies_created", [])
        iterations = data.get("iterations", [])
        regime_winners = final.get("regime_winners", [])
        pruned = final.get("pruned_strategies", [])

        now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M UTC")

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>TECO Report — {html.escape(run_id)}</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>
<style>
{_CSS}
</style>
</head>
<body>

<header>
  <h1>TECO Optimization Report</h1>
  <div class="meta">
    <span class="badge">{html.escape(run_id)}</span>
    <span>{html.escape(device)}</span>
    <span>Peak FP16: {peak_tflops:.0f} TFLOPS</span>
    <span>Peak BW: {peak_bw:.0f} GB/s</span>
    <span>{now}</span>
  </div>
</header>

<section class="summary-cards">
  <div class="card accent">
    <div class="card-value">{overall_speedup:.2f}x</div>
    <div class="card-label">Overall Speedup</div>
  </div>
  <div class="card">
    <div class="card-value">{total_iters}/{max_iters}</div>
    <div class="card-label">Iterations</div>
  </div>
  <div class="card">
    <div class="card-value">{self._fmt_duration(wall_time)}</div>
    <div class="card-label">Wall Time</div>
  </div>
  <div class="card">
    <div class="card-value">{len(regime_winners)}</div>
    <div class="card-label">Regime Winners</div>
  </div>
</section>

<!-- Baseline -->
<section>
  <h2>Baseline Performance</h2>
  {self._render_baseline_table(baseline)}
</section>

<!-- Strategies -->
<section>
  <h2>Strategies</h2>
  {self._render_strategy_table(strategies, regime_winners, pruned)}
</section>

<!-- Performance over iterations chart -->
<section>
  <h2>Performance Over Iterations</h2>
  <div id="chart-iterations" class="chart"></div>
</section>

<!-- Strategy comparison chart -->
<section>
  <h2>Strategy Comparison (Final)</h2>
  <div id="chart-comparison" class="chart"></div>
</section>

<!-- Roofline plot -->
<section>
  <h2>Roofline Analysis</h2>
  <div id="chart-roofline" class="chart"></div>
</section>

<!-- Iteration log -->
<section>
  <h2>Iteration Log</h2>
  {self._render_iteration_log(iterations)}
</section>

<footer>
  Generated by TECO — The Experienced Code Optimizer
</footer>

<script>
{self._render_charts_js(data)}
</script>

</body>
</html>"""

    # ------------------------------------------------------------------
    # HTML fragments
    # ------------------------------------------------------------------

    def _render_baseline_table(self, baseline: list[dict]) -> str:
        if not baseline:
            return "<p>No baseline data.</p>"
        rows = ""
        for b in baseline:
            bn = b.get("bottleneck") or "—"
            rows += (
                f"<tr><td>{html.escape(b['shape'])}</td>"
                f"<td class='num'>{b['latency_ms']:.2f}</td>"
                f"<td class='num'>{b['tflops']:.1f}</td>"
                f"<td>{html.escape(bn)}</td></tr>\n"
            )
        return f"""<table>
<thead><tr><th>Shape</th><th>Latency (ms)</th><th>TFLOPS</th><th>Bottleneck</th></tr></thead>
<tbody>{rows}</tbody>
</table>"""

    def _render_strategy_table(
        self,
        strategies: list[dict],
        winners: list[dict],
        pruned: list[dict],
    ) -> str:
        winner_ids = {w.get("id") for w in winners}
        pruned_ids = {p.get("id") for p in pruned}
        pruned_map = {p.get("id"): p.get("reason", "") for p in pruned}

        rows = ""
        for s in strategies:
            sid = s.get("id", "?")
            name = s.get("name", "?")
            detail = s.get("detail", "")
            if sid in winner_ids:
                w = next((w for w in winners if w.get("id") == sid), {})
                status = f'<span class="badge winner">★ Winner — {html.escape(w.get("regime", ""))}</span>'
            elif sid in pruned_ids:
                status = f'<span class="badge pruned">✗ Pruned — {html.escape(pruned_map.get(sid, ""))}</span>'
            else:
                status = '<span class="badge">Active</span>'
            rows += (
                f"<tr><td>{html.escape(sid)}</td>"
                f"<td>{html.escape(name)}</td>"
                f"<td>{status}</td>"
                f"<td>{html.escape(detail[:80])}</td></tr>\n"
            )
        return f"""<table>
<thead><tr><th>ID</th><th>Name</th><th>Status</th><th>Detail</th></tr></thead>
<tbody>{rows}</tbody>
</table>"""

    def _render_iteration_log(self, iterations: list[dict]) -> str:
        if not iterations:
            return "<p>No iterations recorded.</p>"
        items = ""
        for it in iterations:
            i = it.get("iteration", 0)
            sid = it.get("strategy_id", "?")
            sname = it.get("strategy_name", "?")
            compile_ok = it.get("compile_ok", False)
            correct_ok = it.get("correctness_ok", False)
            wall = it.get("wall_time_s", 0)

            compile_icon = "✓" if compile_ok else "✗"
            correct_icon = "✓" if correct_ok else "✗"
            compile_cls = "ok" if compile_ok else "fail"
            correct_cls = "ok" if correct_ok else "fail"

            shape_rows = ""
            for label, tflops in it.get("shape_results", {}).items():
                pct = it.get("vs_baseline", {}).get(label, 0.0)
                pct_cls = "positive" if pct > 0 else ("negative" if pct < 0 else "")
                shape_rows += (
                    f"<tr><td>{html.escape(label)}</td>"
                    f"<td class='num'>{tflops:.1f}</td>"
                    f"<td class='num {pct_cls}'>{pct:+.1f}%</td></tr>\n"
                )

            items += f"""<details>
<summary>
  <strong>Iter {i + 1}</strong> — [{html.escape(sid)}] {html.escape(sname)}
  <span class="{compile_cls}">{compile_icon} compile</span>
  <span class="{correct_cls}">{correct_icon} correct</span>
  <span class="dim">({wall:.1f}s)</span>
</summary>
<table class="inner">
<thead><tr><th>Shape</th><th>TFLOPS</th><th>vs Baseline</th></tr></thead>
<tbody>{shape_rows}</tbody>
</table>
</details>
"""
        return items

    # ------------------------------------------------------------------
    # Chart JS
    # ------------------------------------------------------------------

    def _render_charts_js(self, data: dict[str, Any]) -> str:
        iterations = data.get("iterations", [])
        baseline = data.get("baseline", [])
        peak_tflops = data.get("peak_tflops_fp16", 0)
        peak_bw = data.get("peak_bandwidth_gbs", 0)

        # ── Performance over iterations ───────────────────────────────────
        # Group by shape label: {label: [{iter, tflops}]}
        shape_labels: list[str] = []
        if baseline:
            shape_labels = [b["shape"] for b in baseline]

        iter_traces = []
        for label in shape_labels:
            xs = []
            ys = []
            for it in iterations:
                if it.get("compile_ok") and it.get("correctness_ok"):
                    xs.append(it["iteration"] + 1)
                    ys.append(it.get("shape_results", {}).get(label, 0))
            iter_traces.append({"x": xs, "y": ys, "name": label, "mode": "lines+markers", "type": "scatter"})

        # Add baseline as horizontal lines
        for b in baseline:
            iter_traces.append({
                "x": [1, max(it["iteration"] + 1 for it in iterations)] if iterations else [1],
                "y": [b["tflops"], b["tflops"]],
                "name": f"{b['shape']} baseline",
                "mode": "lines",
                "line": {"dash": "dash", "width": 1},
                "type": "scatter",
            })

        iter_layout = {
            "xaxis": {"title": "Iteration"},
            "yaxis": {"title": "TFLOPS"},
            "margin": {"t": 30, "b": 50, "l": 60, "r": 20},
            "legend": {"orientation": "h", "y": -0.2},
        }

        # ── Strategy comparison (final iteration per strategy) ────────────
        # Find the last successful iteration per strategy
        last_by_strategy: dict[str, dict] = {}
        for it in iterations:
            if it.get("compile_ok") and it.get("correctness_ok"):
                last_by_strategy[it["strategy_id"]] = it

        comp_traces = []
        for label in shape_labels:
            xs = []
            ys = []
            for sid, it in last_by_strategy.items():
                xs.append(f"{sid} {it.get('strategy_name', '')[:16]}")
                ys.append(it.get("shape_results", {}).get(label, 0))
            comp_traces.append({"x": xs, "y": ys, "name": label, "type": "bar"})

        # Add baseline bars
        for b in baseline:
            xs = list(last_by_strategy.keys())
            ys = [b["tflops"]] * len(xs)
            comp_traces.append({
                "x": [f"{sid} {last_by_strategy[sid].get('strategy_name', '')[:16]}" for sid in xs],
                "y": ys,
                "name": f"{b['shape']} baseline",
                "type": "bar",
                "marker": {"opacity": 0.3},
            })

        comp_layout = {
            "barmode": "group",
            "xaxis": {"title": "Strategy"},
            "yaxis": {"title": "TFLOPS"},
            "margin": {"t": 30, "b": 80, "l": 60, "r": 20},
            "legend": {"orientation": "h", "y": -0.3},
        }

        # ── Roofline plot ─────────────────────────────────────────────────
        # Simple roofline: x = arithmetic intensity, y = TFLOPS
        # Hardware ceilings: compute ceiling (horizontal) and memory ceiling (diagonal)
        roofline_traces = []
        if peak_tflops > 0 and peak_bw > 0:
            # Ridge point
            ridge_ai = peak_tflops * 1e12 / (peak_bw * 1e9)  # FLOP/byte
            ai_range = [0.1, ridge_ai * 4]

            # Memory ceiling line
            mem_x = [ai_range[0], ridge_ai]
            mem_y = [ai_range[0] * peak_bw * 1e9 / 1e12, peak_tflops]
            roofline_traces.append({
                "x": mem_x, "y": mem_y,
                "name": "Memory ceiling",
                "mode": "lines",
                "line": {"color": "rgba(255,100,100,0.7)", "width": 2},
                "type": "scatter",
            })

            # Compute ceiling line
            roofline_traces.append({
                "x": [ridge_ai, ai_range[1]],
                "y": [peak_tflops, peak_tflops],
                "name": "Compute ceiling",
                "mode": "lines",
                "line": {"color": "rgba(100,100,255,0.7)", "width": 2},
                "type": "scatter",
            })

            # Plot baseline points (estimate AI from bottleneck)
            for b in baseline:
                # Rough AI estimate: if memory-bound, AI < ridge; if compute-bound, AI > ridge
                bn = b.get("bottleneck", "")
                if bn == "memory":
                    ai = ridge_ai * 0.3
                elif bn == "compute":
                    ai = ridge_ai * 2.0
                else:
                    ai = ridge_ai * 0.8
                roofline_traces.append({
                    "x": [ai], "y": [b["tflops"]],
                    "name": f"Baseline {b['shape']}",
                    "mode": "markers",
                    "marker": {"size": 10, "symbol": "circle"},
                    "type": "scatter",
                })

            # Plot final strategy points
            for sid, it in last_by_strategy.items():
                for label, tflops in it.get("shape_results", {}).items():
                    # Estimate AI similarly
                    ai = ridge_ai * 1.0  # placeholder
                    roofline_traces.append({
                        "x": [ai], "y": [tflops],
                        "name": f"{sid} {label}",
                        "mode": "markers",
                        "marker": {"size": 10, "symbol": "diamond"},
                        "type": "scatter",
                    })

        roofline_layout = {
            "xaxis": {"title": "Arithmetic Intensity (FLOP/byte)", "type": "log"},
            "yaxis": {"title": "TFLOPS", "type": "log"},
            "margin": {"t": 30, "b": 50, "l": 60, "r": 20},
            "legend": {"orientation": "h", "y": -0.2},
        }

        return f"""
// Performance over iterations
Plotly.newPlot('chart-iterations',
  {json.dumps(iter_traces)},
  {json.dumps(iter_layout)},
  {{responsive: true}}
);

// Strategy comparison
Plotly.newPlot('chart-comparison',
  {json.dumps(comp_traces)},
  {json.dumps(comp_layout)},
  {{responsive: true}}
);

// Roofline
Plotly.newPlot('chart-roofline',
  {json.dumps(roofline_traces)},
  {json.dumps(roofline_layout)},
  {{responsive: true}}
);
"""

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _fmt_duration(seconds: float) -> str:
        if seconds < 60:
            return f"{seconds:.1f}s"
        minutes = int(seconds // 60)
        secs = seconds % 60
        if minutes < 60:
            return f"{minutes}m {secs:.0f}s"
        hours = minutes // 60
        mins = minutes % 60
        return f"{hours}h {mins}m {secs:.0f}s"


# ---------------------------------------------------------------------------
# Embedded CSS
# ---------------------------------------------------------------------------

_CSS = """
:root {
  --bg: #0d1117;
  --surface: #161b22;
  --border: #30363d;
  --text: #c9d1d9;
  --text-dim: #8b949e;
  --accent: #58a6ff;
  --green: #3fb950;
  --red: #f85149;
  --yellow: #d29922;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

header {
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 1rem;
}

header h1 {
  color: var(--accent);
  font-size: 1.8rem;
  margin-bottom: 0.5rem;
}

.meta {
  display: flex;
  gap: 1.5rem;
  flex-wrap: wrap;
  color: var(--text-dim);
  font-size: 0.9rem;
}

.badge {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 2px 8px;
  font-size: 0.85rem;
}

.badge.winner {
  background: rgba(63, 185, 80, 0.15);
  border-color: var(--green);
  color: var(--green);
}

.badge.pruned {
  background: rgba(248, 81, 73, 0.1);
  border-color: var(--red);
  color: var(--red);
}

.summary-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 1.2rem;
  text-align: center;
}

.card.accent {
  border-color: var(--accent);
}

.card-value {
  font-size: 2rem;
  font-weight: bold;
  color: var(--accent);
}

.card.accent .card-value {
  color: var(--green);
}

.card-label {
  color: var(--text-dim);
  font-size: 0.85rem;
  margin-top: 0.3rem;
}

section {
  margin-bottom: 2rem;
}

h2 {
  color: var(--accent);
  font-size: 1.3rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 0.3rem;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 1rem;
}

th, td {
  padding: 0.5rem 0.8rem;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

th {
  color: var(--text-dim);
  font-weight: 600;
  font-size: 0.85rem;
  text-transform: uppercase;
}

td.num {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

.positive { color: var(--green); }
.negative { color: var(--red); }

.chart {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 1rem;
  min-height: 350px;
}

details {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-bottom: 0.5rem;
}

details summary {
  padding: 0.6rem 1rem;
  cursor: pointer;
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
}

details summary:hover {
  background: rgba(88, 166, 255, 0.05);
}

details[open] summary {
  border-bottom: 1px solid var(--border);
}

details .inner {
  margin: 0.5rem 1rem 1rem;
}

.ok { color: var(--green); }
.fail { color: var(--red); font-weight: bold; }
.dim { color: var(--text-dim); font-size: 0.85rem; }

footer {
  text-align: center;
  color: var(--text-dim);
  font-size: 0.8rem;
  margin-top: 3rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border);
}
"""
